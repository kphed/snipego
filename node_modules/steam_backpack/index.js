module.exports = BackpackLogger;

// == require our dependencies == //
var winston = require('winston');

// == setup winston logger interfaces == //
var logger = new (winston.Logger)({
	transports: [
	new (winston.transports.Console)({level : 'info', colorize: 'all', prettyPrint: true}),
	new (winston.transports.File)({filename: __dirname+'/logs/error.log', level: 'error'})
	]
});

// == constructor for logger == //
function BackpackLogger(config) {
  this.logger = logger;
  this._config = config || {};

  var default_options = {
    "table_name" : "backpack",
		"expired_offers_cutoff_time" : 3, // == offers that have been pending for more than this time(minutes) are to be canceled == //
    "poll_interval" : (10)*1000 // == miliseconds == //
  }

  // == check for options set and if not set init to the default == //
  for(var i in default_options) {
    if(!this._config.hasOwnProperty(i)) {
      this._config[i] = default_options[i];
    }
  }

  this.que = this._config.que || [];

  if(typeof this._config.client === 'undefined') {
    logger.log("error", "Please give the logger a steam client with a trade offers api");
    process.exit();
  } else {
    this.client = this._config.client;
  }

	if(typeof this._config.bot_info === 'undefined') {
		logger.log("error", "Please give the information for the bot's inventory you want it to track");
		process.exit();
	} else {
		this.bot_info = this._config.bot_info;
	}
};

// == start polling for changes to our sent offers == //
BackpackLogger.prototype.start = function() {
	var self = this;

  self.offer_loop = setTimeout(self._check_offers.bind(self));
  self.cancel_loop = setTimeout(self._cancel_offers.bind(self));
};

// == loop thourhgh our list of pending offers and deposit or withdraw accordingly == //
BackpackLogger.prototype._check_offers = function() {
	var self = this;

	self.client.getOffers({
		get_sent_offers: 1,
			active_only: 1,		// == offers are considered active so long they arent more than a minute older than the expired offers cuttoff timelimit == //
			time_historical_cutoff: Math.round(Date.now() / 1000) - ((self._config.expired_offers_cutoff_time+1)*60)
	}, function(err,body) {
		if(err) {
			logger.log("Couldnt connect to steam to get trade offers :"+err);
			return;
		}

		var steam_offers = body.response.trade_offers_sent || [];

		// foreach offer in our object pending offers list. seach for a coressponding match in our que and keep only the items that we find (we only care about qued offers)
		var steam_offers_we_care_about = steam_offers.filter(function(element, index) {
			return self.que.indexOf(element.tradeofferid) > -1;
		});

		for(var i = 0; i < steam_offers_we_care_about.length; i++) {
			var offer = steam_offers_we_care_about[i];

			// if the offer is not pending acceptance nor has it been accepted. remove it from our watchlist
			if(offer.trade_offer_state !== 2 && offer.trade_offer_state !== 3) {
					self.que.splice(self.que.indexOf(offer.tradeofferid), 1);
					continue;
			}

			// If the user accepted the offer
			// refrence : https://developer.valvesoftware.com/wiki/Steam_Web_API/IEconService#ETradeOfferState
			if(offer.trade_offer_state === 3) {

				// this was a deposit request ...
				if(offer.items_to_receive) {
					self._deposit_items(offer);

					// now remove the offer from que
					self.que.splice(self.que.indexOf(offer.tradeofferid), 1);
			} else if(offer.items_to_give) {
				self._withdraw_items(offer);

				self.que.splice(self.que.indexOf(offer.tradeofferid), 1);
			} else {

				// we really arent suppose to fucking get here. Fucking steam.  its either suppose to deposit with items to receive or a withdraw with items to give up.
				// @note it wont be both because we're the ones making the offer
				// @note propably the effect of inventories being delayed
				logger.log("warn", "Trade offer accepted but no items to give or to recieve in trade. Inventories propably delayed", offer);
			}
		} // end of state === 3 if statment
	} // end offers for loop

	logger.log("info", "offers being tracked for acceptance : "+self.que.length);
});

	// Check the status of our sent trade offers again in x secs
	self.offer_loop = setTimeout(self._check_offers.bind(self), self._config.poll_interval);
};

// == cancel the offers we sent out that have been pending more than x time
BackpackLogger.prototype._cancel_offers = function() {
	var self = this;

	self.client.getOffers({
		get_sent_offers :1,
			active_only: 1,
			time_historical_cutoff: Math.round(Date.now() / 1000) + (10000) //really high timestamp so we get only active offers pending acceptance
	}, function(get_offers_error, offers){

		if(get_offers_error) {
			return;
		}

		offers = offers.response.trade_offers_sent || [];

		var expired_offers_cutoff_time = Math.round(Date.now() / 1000) - (self._config.expired_offers_cutoff_time*60);

		var offers_we_care_about = offers.filter(function(offer, offer_index) {
			return  (offer.trade_offer_state === 2) && offer.time_created < expired_offers_cutoff_time;
		});

		offers_we_care_about.forEach(function(offer, offer_index) {
			logger.log("info", "canceling expired offer ID: "+offer.tradeofferid);
			self.client.cancelOffer({tradeOfferId: offer.tradeofferid});
		});
	});

	// Run the sweeper again
	self.cancel_loop = setTimeout(self._cancel_offers.bind(self),  self._config.poll_interval);
};

// == deposit the items from an offer into the user's backpack == //
BackpackLogger.prototype._deposit_items = function(offer) {
	var self = this;

  self.client.getItems({tradeId : offer.tradeid}, function(get_items_err, offer_items) {

    if(get_items_err) {
      logger.log("error", get_items_err);
      return;
    }

    // get a array of the values we want to insert one after the other in our query
    var query_values = offer_items.map(function(item, item_index) {
      return  {"item" : item.name, "assetid" : item.id, "appid" : item.appid, "contextid" : item.contextid, "amount" : item.amount, "classid" : item.classid, "instanceid" : item.instanceid, "icon_url" : item.icon_url, "icon_url_large" : item.icon_url_large, "market_hash_name" : item.market_hash_name, "bot" : self.bot_info.id};
    });

    // create the db connection
    var connection = self._config.db_info.FireBase;

		var jackpot = connection.child("jackpot");

		// == fetch last round then .. == //
		jackpot.orderByKey().limitToLast(1).once("value", function(data) {

			// if no rounds yet create one
			if(data.val() == null) {
				current_round = jackpot.push().key();
			} else {
				current_round = Object.keys(data.val())[0];
				logger.log("info", "current_round", current_round);
			}

			jackpot.child(current_round).child("players").push({
				steamid : offer.steamid_other,
				skins : query_values
			});
		});
  }); // end of fetch items callback
};

// == withdraw items form user's backpack == //
BackpackLogger.prototype._withdraw_items = function(offer) {
	var self = this;
  var connection = mysql.createConnection({host: self._config.db_info.host, database: self._config.db_info.db, user: self._config.db_info.db_username, password: self._config.db_info.db_password});
  var delete_count = 0;

  // log items in our database with user info
  connection.beginTransaction(function(err) {
    if(err) {
      logger.log("error", "coundnt begin transaction code:"+err.code, offer);

			// if the error didnt close the connection close it up ourself
			if(!err.fatal) {
				connection.rollback();
				connnection.destroy();
			}

      return;
    }

    for(var i= 0; i<offer.items_to_give.length; i++) {
      connection.query("DELETE FROM `"+self._config.db_info.item_table+"` WHERE `assetid` = ? AND `appid` = ? AND `contextid` = ?", [offer.items_to_give[i].assetid, offer.items_to_give[i].appid, offer.items_to_give[i].contextid],
       function(query_error, results, feilds) {
         if(query_error) {
            logger.log("error", "query error : failed to delete items withdrawn from inventory:"+query_error.code, offer);

						// if the error didnt close the connection close it up ourself(if it was the last in our callback que)
						if(!query_error.fatal) {
							connection.rollback();
							if(i === offer.items_to_give.length - 1) {
								connection.destroy;
							}
						}

            return;
         }

         // increment the amount of items we have removed from the offer
         ++delete_count;

         // if we have removed all the items from the offer's list
         if(delete_count === offer.items_to_give.length) {
           connection.commit(function(commit_error) {
             if(commit_error) {
               logger.log("error", "couldnt commit user items to db commit code: "+commit_error.code, offer);

							 // if the error didnt close the connection close it up ourself
							 if(!commit_error.fatal) {
								 connection.rollback();
								 connnection.destroy();
							 }

               return;
             }

             connection.end();
             logger.log("info", "user accepted offer and items withdrawn from inventory. Trade ID :"+offer.tradeid);
           });
         } // === end of delect count condition == //
      });
    }
  });
};
